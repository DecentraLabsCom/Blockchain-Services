# Server configuration
base.domain=https://sarlab.dia.uned.es

# Auth base path for issuer URLs
auth.base-path=/auth

# Endpoint paths
endpoint.health=/health
endpoint.wallet-auth=/auth/wallet-auth
endpoint.wallet-auth2=/auth/wallet-auth2
endpoint.saml-auth=/auth/saml-auth
endpoint.saml-auth2=/auth/saml-auth2
endpoint.jwks=/auth/jwks
endpoint.message=/auth/message
endpoint.wallet=/wallet
endpoint.treasury=/treasury

# Feature toggles
features.providers.enabled=true

server.tomcat.uri-encoding=UTF-8
spring.jndi.ignore=true

# Set the server port to 8080 (default)
server.port=8080

# Enable debugging for Spring Boot logs
#logging.level.org.springframework=DEBUG
#logging.level.org.springframework.web=DEBUG

# Blockchain and smart contract configuration
# SECURITY: These values should be provided via environment variables in production
# Set them in Docker: -e CONTRACT_ADDRESS=0x... -e ETHEREUM_SEPOLIA_RPC_URL=https://... etc.
contract.address=${CONTRACT_ADDRESS:0xC332F296d698bb05Fbad7863131F36085F6ce66d}

# Institutional Wallet Configuration
# The institutional wallet is used for ALL automated transactions:
# - Event listener automatic confirmations/denials
# - Institutional reservations (treasury operations)
# - Administrative operations (treasury admin)
#
# SETUP (one-time):
# 1. Create wallet: POST /wallet/create {"password": "YourSecurePassword"}
# 2. Copy the returned address
# 3. Configure these environment variables:
#    - INSTITUTIONAL_WALLET_ADDRESS=0xYourWalletAddress
#    - INSTITUTIONAL_WALLET_PASSWORD=YourSecurePassword
# 4. Restart the service
#
# SECURITY:
# - Wallet private key is AES-256-GCM encrypted in /app/data/wallets.json
# - Only the password is in environment variables (rotatable)
# - Use AWS Secrets Manager / Azure Key Vault for production
# - Never commit the password to version control
#
# CRITICAL SECURITY: Never commit the actual password to version control!
# This MUST be provided as an environment variable in production:
# docker run -e INSTITUTIONAL_WALLET_PASSWORD=YourActualPassword ...
institutional.wallet.address=${INSTITUTIONAL_WALLET_ADDRESS:}
institutional.wallet.password=${INSTITUTIONAL_WALLET_PASSWORD:}

# Trust Mode for IdPs
# - whitelist: Only trust specific IdPs listed below (more secure)
# - any: Trust any IdP with valid SAML signature (less secure, but more flexible)
saml.idp.trust-mode=any

# Trusted IdP Issuers (only used if trust-mode=whitelist)
# Format: {'institutionId':'idpIssuerUrl', 'institutionId2':'idpIssuerUrl2'}
saml.trusted.idp={'uned':'https://idp.uned.es','ucm':'https://idp.ucm.es'}

# JWT Encryption configuration
# SECURITY: In production, mount these as Docker volumes with restricted permissions (chmod 400)
# Example: docker run -v /secure/path/keys:/app/config/keys:ro ...
private.key.path=${PRIVATE_KEY_PATH:/app/config/keys/private_key.pem}
public.key.path=${PUBLIC_KEY_PATH:/app/config/keys/public_key.pem}
public.certificate.path=${PUBLIC_CERTIFICATE_PATH:/app/config/keys/certificate.pem}

# Spring Security configuration - Check for production
allowed-origins=http://localhost:3000,https://marketplace-decentralabs.vercel.app

# Marketplace JWT authentication
# URL where the marketplace exposes its public key for JWT validation
marketplace.public-key-url=https://marketplace-decentralabs.vercel.app/.well-known/public-key.pem
# marketplace.key.cache-ms=3600000

# Security Notes:
# 1. The marketplace.public-key-url should serve a PEM-encoded RSA public key
# 2. The marketplace endpoint should be secured with HTTPS
# 3. The blockchain service caches the public key for 24 hours and refreshes on signature failures
# 4. JWTs from marketplace should include user claims like:
#    - sub: user identifier
#    - email: user email
#    - uid: user ID from SAML
#    - displayName: user display name
#    - schacHomeOrganization: user affiliation
#    - eduPersonAffiliation: user role
#    - eduPersonScopedAffiliation: scoped role
# 5. Example marketplace public key endpoint format:
#    GET https://marketplace-decentralabs.vercel.app/.well-known/public-key.pem
#    Content-Type: text/plain
#    Response: -----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFA...\n-----END PUBLIC KEY-----

# Wallet Service Configuration
# Encryption settings for wallet private keys
# SECURITY: Change this salt in production via environment variable
wallet.encryption.salt=${WALLET_ENCRYPTION_SALT:DecentraLabs2025}
# Default wallet address (can be overridden via environment variable)
wallet.address=${WALLET_ADDRESS:0x0000000000000000000000000000000000000000}

# Network-specific RPC configurations
# SECURITY: Use environment variables for RPC URLs with API keys in production
# Example: -e ETHEREUM_MAINNET_RPC_URL=https://mainnet.infura.io/v3/YOUR_ACTUAL_PROJECT_ID
# Example: -e ETHEREUM_SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_ACTUAL_PROJECT_ID
#
# FALLBACK SUPPORT: Multiple RPC endpoints separated by commas
# System will automatically try the next endpoint if one fails
# Example: ethereum.sepolia.rpc.url=https://rpc1.com,https://rpc2.com,https://rpc3.com
#
# Public endpoints (free, but rate-limited and may be slow):
# - Sepolia: https://rpc.sepolia.org, https://rpc2.sepolia.org, https://1rpc.io/sepolia
# - Mainnet: https://eth.public-rpc.com
#
# Recommended providers (free tier available):
# - Infura: https://infura.io (100k requests/day free)
# - Alchemy: https://alchemy.com (300M compute units/month free)
ethereum.mainnet.rpc.url=${ETHEREUM_MAINNET_RPC_URL:https://eth.public-rpc.com}
ethereum.sepolia.rpc.url=${ETHEREUM_SEPOLIA_RPC_URL:https://rpc.sepolia.org,https://rpc2.sepolia.org,https://1rpc.io/sepolia}

# Wallet security settings
wallet.max.transactions.per.hour=100
wallet.max.balance.checks.per.minute=60

# Wallet Persistence Configuration
# Enable persistent storage of encrypted wallets (survives service restarts)
wallet.persistence.enabled=false
# Path to wallet storage file (wallets are already AES-256-GCM encrypted)
# SECURITY: Ensure this directory has restricted permissions (chmod 700)
wallet.persistence.file.path=${WALLET_FILE_PATH:./data/wallets.json}

# Anti-Replay Protection
# For single instance: in-memory works fine (5 min expiration)
# For multiple instances: implement Redis persistence
antireplay.persistence.enabled=false

# Gas price settings (in gwei)
ethereum.gas.price.default=0.3
ethereum.gas.limit.default=21000
ethereum.gas.limit.contract=100000

# Contract Event Listening Configuration
# Events to listen for from the Diamond contract (comma-separated)
contract.events.to.listen=ReservationRequested,ReservationRequestDenied,ReservationRequestCanceled,ReservationConfirmed,BookingCanceled

# Event listening settings
contract.event.listening.enabled=true
contract.event.start.block=latest
