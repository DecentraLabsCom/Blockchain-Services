# Server configuration
# Can be overridden via BASE_DOMAIN environment variable (e.g., when running in Lab Gateway)
base.domain=${BASE_DOMAIN:}

# Auth base path for issuer URLs (must remain /auth to match the gateway)
auth.base-path=/auth

# Endpoint paths
endpoint.health=/health
endpoint.wallet-auth=/auth/wallet-auth
endpoint.wallet-auth2=/auth/wallet-auth2
endpoint.saml-auth=/auth/saml-auth
endpoint.saml-auth2=/auth/saml-auth2
endpoint.jwks=/auth/jwks
endpoint.message=/auth/message
endpoint.wallet=/wallet
endpoint.treasury=/treasury
endpoint.intents=/intents

# Intents configuration
intents.api-key=${INTENTS_API_KEY:}
intent.trusted-signer=${INTENT_TRUSTED_SIGNER:}
intent.default-eta=${INTENT_DEFAULT_ETA:15s}
intent.domain.name=${INTENT_DOMAIN_NAME:DecentraLabsIntent}
intent.domain.version=${INTENT_DOMAIN_VERSION:1}
intent.domain.chain-id=${INTENT_DOMAIN_CHAIN_ID:11155111}
intent.domain.verifying-contract=${INTENT_DOMAIN_VERIFYING_CONTRACT:0x0000000000000000000000000000000000000000}
intent.reconciliation-interval-ms=${INTENT_RECONCILIATION_INTERVAL_MS:10000}
intent.webhook.url=${INTENT_WEBHOOK_URL:}
intent.webhook.secret=${INTENT_WEBHOOK_SECRET:}
intent.execution-interval-ms=${INTENT_EXECUTION_INTERVAL_MS:5000}
webauthn.credentials.table=${WEBAUTHN_CREDENTIALS_TABLE:webauthn_credentials}

# WebAuthn Onboarding Configuration
# These settings configure the WIB as a WebAuthn Relying Party for user credential registration
# RP ID: The effective domain for WebAuthn. Must match the domain users see in browser.
# In Lab Gateway mode, this should be set to the gateway's domain (e.g., lab.institution.edu)
webauthn.rp.id=${WEBAUTHN_RP_ID:${BASE_DOMAIN:localhost}}
webauthn.rp.name=${WEBAUTHN_RP_NAME:DecentraLabs Gateway}

# Allowed origins for WebAuthn attestation. Browser origin must match one of these.
# Include both the gateway URL and any SP/marketplace URLs that redirect users here.
# In Lab Gateway mode: https://lab.institution.edu (and any additional HTTPS variants)
webauthn.rp.origins=${WEBAUTHN_RP_ORIGINS:https://localhost,https://localhost:443,https://localhost:8443}

# WebAuthn ceremony timeout (milliseconds). User has this long to complete the ceremony.
webauthn.timeout.ms=${WEBAUTHN_TIMEOUT_MS:120000}

# Onboarding session TTL (seconds). Challenge expires after this time.
webauthn.session.ttl.seconds=${WEBAUTHN_SESSION_TTL_SECONDS:300}

# Session cleanup interval (seconds). How often to purge expired sessions.
webauthn.session.cleanup.interval.seconds=${WEBAUTHN_SESSION_CLEANUP_INTERVAL_SECONDS:60}

# Attestation conveyance preference: "none", "indirect", or "direct"
# "none" is recommended for privacy (no hardware attestation sent to server)
webauthn.attestation.conveyance=${WEBAUTHN_ATTESTATION_CONVEYANCE:none}

# Authenticator attachment: "platform", "cross-platform", or empty (no preference)
# "platform" = TouchID/FaceID/Windows Hello, "cross-platform" = YubiKey, etc.
webauthn.authenticator.attachment=${WEBAUTHN_AUTHENTICATOR_ATTACHMENT:}

# Resident key (discoverable credential) preference: "required", "preferred", or "discouraged"
webauthn.resident-key=${WEBAUTHN_RESIDENT_KEY:preferred}

# User verification preference: "required", "preferred", or "discouraged"
webauthn.user-verification=${WEBAUTHN_USER_VERIFICATION:preferred}

# Base URL for the IB. Used to construct the onboardingUrl in /options response.
# If not set, defaults to https://{webauthn.rp.id}
# Example: https://gateway.institution.edu
webauthn.base-url=${WEBAUTHN_BASE_URL:}

# Feature toggles
features.providers.enabled=true
# Enable organization onboarding features and configure invite settings
features.organizations.enabled=${FEATURES_ORGANIZATIONS_ENABLED:true}
organization.invite.hmac-secret=${ORGANIZATION_INVITE_HMAC_SECRET:}
organization.invite.default-issuer=${ORGANIZATION_INVITE_DEFAULT_ISSUER:DecentraLabs Marketplace}

# Marketplace URL for wallet dashboard
marketplace.url=${MARKETPLACE_URL:https://marketplace-decentralabs.vercel.app}

server.tomcat.uri-encoding=UTF-8

# Set the server port to 8080 (default)
server.port=8080

# Enable debugging for Spring Boot logs
#logging.level.org.springframework=DEBUG
#logging.level.org.springframework.web=DEBUG

# Blockchain and smart contract configuration
# SECURITY: These values should be provided via environment variables in production
# Set them in Docker: -e CONTRACT_ADDRESS=0x... -e ETHEREUM_SEPOLIA_RPC_URL=https://... etc.
contract.address=${CONTRACT_ADDRESS:0xC332F296d698bb05Fbad7863131F36085F6ce66d}

# Institutional Wallet Configuration
# The institutional wallet is used for ALL automated transactions and is
# normally created/imported via /wallet-dashboard:
# - Event listener automatic confirmations/denials
# - Institutional reservations (treasury operations)
# - Administrative operations (treasury admin)
#
# Default flow:
# 1. Start the container and open /wallet-dashboard
# 2. Create or import the wallet (choose a password)
# 3. The service encrypts it into /app/data/wallets.json and writes
#    address/password to /app/data/wallet-config.properties
# 4. The wallet is hot-reloaded automatically (no restart needed)
#
# Overrides:
# - Provide INSTITUTIONAL_WALLET_* env vars only if you prefer secrets managers
#   or need to preconfigure the wallet via CI/CD.
# - Env vars > wallet-config.properties > auto-detected persistence metadata.
#
# SECURITY:
# - Wallet private key is AES-256-GCM encrypted in /app/data/wallets.json
# - Passwords should come from a secret manager in production
# - Never commit credentials to version control
institutional.wallet.address=${INSTITUTIONAL_WALLET_ADDRESS:}
institutional.wallet.password=${INSTITUTIONAL_WALLET_PASSWORD:}

# Trust Mode for IdPs
# - whitelist: Only trust specific IdPs listed below (more secure)
# - any: Trust any IdP with valid SAML signature (less secure, but more flexible)
saml.idp.trust-mode=any

# Trusted IdP Issuers (only used if trust-mode=whitelist)
# Format: {'institutionId':'idpIssuerUrl', 'institutionId2':'idpIssuerUrl2'}
saml.trusted.idp={'uned':'https://idp.uned.es','ucm':'https://idp.ucm.es'}

# JWT Encryption configuration
# SECURITY: In production, mount these as Docker volumes with restricted permissions (chmod 400)
# Example: docker run -v /secure/path/keys:/app/config/keys:ro ...
private.key.path=${PRIVATE_KEY_PATH:/app/config/keys/private_key.pem}
public.key.path=${PUBLIC_KEY_PATH:/app/config/keys/public_key.pem}

# Administrative dashboard security
admin.dashboard.local-only=${ADMIN_DASHBOARD_LOCAL_ONLY:true}
admin.dashboard.allow-private=${ADMIN_DASHBOARD_ALLOW_PRIVATE:true}
security.allow-private-networks=${SECURITY_ALLOW_PRIVATE_NETWORKS:true}

# Spring Security configuration - Check for production
allowed-origins=http://localhost:3000,https://marketplace-decentralabs.vercel.app
wallet.allowed-origins=http://localhost:3000,http://127.0.0.1:3000,https://localhost,https://localhost:443,https://localhost:8443

# Marketplace JWT authentication
# URL where the marketplace exposes its public key for JWT validation
marketplace.public-key-url=https://marketplace-decentralabs.vercel.app/.well-known/public-key.pem
# marketplace.key.cache-ms=3600000

# Security Notes:
# 1. The marketplace.public-key-url should serve a PEM-encoded RSA public key
# 2. The marketplace endpoint should be secured with HTTPS
# 3. The blockchain service caches the public key for 24 hours and refreshes on signature failures
# 4. JWTs from marketplace should include user claims like:
#    - sub: user identifier
#    - email: user email
#    - uid: user ID from SAML
#    - displayName: user display name
#    - schacHomeOrganization: user affiliation
#    - eduPersonAffiliation: user role
#    - eduPersonScopedAffiliation: scoped role
# 5. Example marketplace public key endpoint format:
#    GET https://marketplace-decentralabs.vercel.app/.well-known/public-key.pem
#    Content-Type: text/plain
#    Response: -----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFA...\n-----END PUBLIC KEY-----

# Wallet Service Configuration
# Default wallet address (can be overridden via environment variable)
wallet.address=${WALLET_ADDRESS:0x0000000000000000000000000000000000000000}

# Network-specific RPC configurations
# SECURITY: Use environment variables for RPC URLs with API keys in production
# Example: -e ETHEREUM_MAINNET_RPC_URL=https://mainnet.infura.io/v3/YOUR_ACTUAL_PROJECT_ID
# Example: -e ETHEREUM_SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_ACTUAL_PROJECT_ID
#
# FALLBACK SUPPORT: Multiple RPC endpoints separated by commas
# System will automatically try the next endpoint if one fails
# Example: ethereum.sepolia.rpc.url=https://rpc1.com,https://rpc2.com,https://rpc3.com
#
# Public endpoints (free, but rate-limited and may be slow):
# - Sepolia: https://rpc.sepolia.org, https://rpc2.sepolia.org, https://1rpc.io/sepolia
# - Mainnet: https://eth.public-rpc.com
#
# Recommended providers (free tier available):
# - Infura: https://infura.io (100k requests/day free)
# - Alchemy: https://alchemy.com (300M compute units/month free)

# Default active network (mainnet or sepolia)
blockchain.network.active=${BLOCKCHAIN_NETWORK_ACTIVE:sepolia}

ethereum.mainnet.rpc.url=${ETHEREUM_MAINNET_RPC_URL:https://eth.public-rpc.com}
ethereum.sepolia.rpc.url=${ETHEREUM_SEPOLIA_RPC_URL:https://1rpc.io/sepolia,https://ethereum-sepolia-rpc.publicnode.com,https://eth-sepolia.api.onfinality.io/public,https://0xrpc.io/sep,https://eth-sepolia.g.alchemy.com/v2/demo}

# Wallet security settings
wallet.max.transactions.per.hour=100
wallet.max.balance.checks.per.minute=60

# Wallet Persistence Configuration
# Enable persistent storage of encrypted wallets (survives service restarts)
wallet.persistence.enabled=true
# Path to wallet storage file (wallets are already AES-256-GCM encrypted)
# SECURITY: Ensure this directory has restricted permissions (chmod 700)
wallet.persistence.file.path=${WALLET_FILE_PATH:./data/wallets.json}

# Wallet Configuration Encryption
# Encryption key for wallet password in wallet-config.properties (auto-generated on first wallet creation)
wallet.config.encryption-key=${WALLET_CONFIG_ENCRYPTION_KEY:}
# Path where the auto-generated encryption key is stored (must live on a persistent volume)
wallet.config.encryption-key-file=${WALLET_CONFIG_KEY_FILE:/app/data/.wallet-encryption-key}

# Anti-Replay Protection
# For single instance: in-memory works fine (5 min expiration)
# For multiple instances: implement Redis persistence
antireplay.persistence.enabled=false

# Gas price settings (in gwei)
# Must be an integer for BigInteger conversion; use 1 gwei as safe default
ethereum.gas.price.default=1
ethereum.gas.limit.default=21000
ethereum.gas.limit.contract=100000

# Contract Event Listening Configuration
# Events to listen for from the Diamond contract (comma-separated)
contract.events.to.listen=ReservationRequested,ReservationRequestDenied,ReservationRequestCanceled,ReservationConfirmed,BookingCanceled,ProviderAdded,LabIntentProcessed,ReservationIntentProcessed

# Event listening settings
contract.event.listening.enabled=true
contract.event.start.block=latest

# Polling fallback for unreliable RPC nodes (free/public endpoints often drop WebSocket connections)
# When enabled, the system uses both WebSocket subscriptions (real-time) and HTTP polling (fallback)
contract.event.polling.enabled=${CONTRACT_EVENT_POLLING_ENABLED:true}
# Polling interval in seconds (how often to check for missed events)
contract.event.polling.interval.seconds=${CONTRACT_EVENT_POLLING_INTERVAL:60}
# Maximum block range per poll (prevents timeouts on large ranges)
contract.event.polling.block.range=${CONTRACT_EVENT_POLLING_BLOCK_RANGE:1000}
# Initial lookback blocks when starting (catches recent events on startup)
contract.event.polling.lookback.blocks=${CONTRACT_EVENT_POLLING_LOOKBACK:100}

# Provider schac capture & persistence

# Reservation notifications (email + ICS)
notifications.mail.enabled=${NOTIFICATIONS_MAIL_ENABLED:true}
notifications.mail.driver=${NOTIFICATIONS_MAIL_DRIVER:noop}
notifications.mail.from=${NOTIFICATIONS_MAIL_FROM:}
notifications.mail.from-name=${NOTIFICATIONS_MAIL_FROM_NAME:Lab Gateway}
notifications.mail.default-to=${NOTIFICATIONS_MAIL_DEFAULT_TO:}
notifications.mail.timezone=${NOTIFICATIONS_MAIL_TIMEZONE:UTC}

notifications.mail.smtp.host=${NOTIFICATIONS_MAIL_SMTP_HOST:}
notifications.mail.smtp.port=${NOTIFICATIONS_MAIL_SMTP_PORT:587}
notifications.mail.smtp.username=${NOTIFICATIONS_MAIL_SMTP_USERNAME:}
notifications.mail.smtp.password=${NOTIFICATIONS_MAIL_SMTP_PASSWORD:}
notifications.mail.smtp.auth=${NOTIFICATIONS_MAIL_SMTP_AUTH:true}
notifications.mail.smtp.start-tls=${NOTIFICATIONS_MAIL_SMTP_STARTTLS:true}
notifications.mail.smtp.timeout-ms=${NOTIFICATIONS_MAIL_SMTP_TIMEOUT_MS:10000}

notifications.mail.graph.tenant-id=${NOTIFICATIONS_MAIL_GRAPH_TENANT_ID:}
notifications.mail.graph.client-id=${NOTIFICATIONS_MAIL_GRAPH_CLIENT_ID:}
notifications.mail.graph.client-secret=${NOTIFICATIONS_MAIL_GRAPH_CLIENT_SECRET:}
notifications.mail.graph.from=${NOTIFICATIONS_MAIL_GRAPH_FROM:}
notifications.config-file=${NOTIFICATIONS_CONFIG_FILE:./data/notifications-config.json}
